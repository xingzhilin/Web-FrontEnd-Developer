<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法 
            构造函数，原型，实例之间的关系：每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针思想：在子类构造函数的内部调用超类构造函数,通过使用call()和apply()方法可以在新创建的对象上执行构造函数 
            具体实现：
        */
        function Super(val){
            this.val = val;//可以传递参数
            this.arr = [1];
            this.fun = function(){
            }
        }
        function Sub(val){
            Super.call(this,val);//核心代码
            //通过call()和apply()方法在新创建的对象上执行构造函数
        }
        var sub1 = new Sub(1);
        var sub2 = new Sub(2);
        sub1.arr.push(2);
        console.log(sub1.val);//1
        console.log(sub2.val);//2
        console.log(sub1.arr);//1,2
        console.log(sub2.arr);//1
        console.log(sub1.fun === sub2.fun);//false
        console.log(sub1.arr === sub2.arr);//false


        /*
           2.核心

                借用父类的构造函数来增强子类实例，等于是把父类的实例属性复制一份给子类实例装上（完全没用到原型） 
          3.优缺点 
            优点： 
                1.解决了子类实例共享父类引用的属性问题 
                2.创建子类实例时可以向父类构造函数传参 
                3.可以实现多继承（call多个父类对象） 
            缺点 ： 
                1.实例并不是父类的实例，只是子类的实例 
                2.只能继承父类的实例属性和方法，不能继承原型属性/方法 
                3.无法实现函数的复用，每个子类都有父类实例函数的副本，例子中每个子类都持有一个新的fun函数,函数无法复用，这就是console.log(sub1.fun === sub2.fun)返回false的原因这就是太多了影响性能，内存爆炸
        */




    </script>
</body>
</html>