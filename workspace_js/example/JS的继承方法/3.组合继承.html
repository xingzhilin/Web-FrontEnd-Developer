<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <script>
        /*
            思路：使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对函数实例属性的继承.这样，既通过在原型上定义方法实现了函数的复用，又保证本了每个实例都有它自己的属性 
            具体实现：
        */
        function Super(){
            //再次只声明基本属性和引用属性
            this.val = 1;
            this.arr = [1];

        }
        //在此声明函数
        Super.prototype.fun1 = function(){};
        Super.prototype.fun2 = function(){};
        function Sub(){
            Super.call(this);//从父类拷贝一份父类的实例属性给子类作为子类的实例属性
        }

        Sub.prototype = new Super();//创建父类实例作为子类的原型 ，此时这个父类实例就又有了一份实例属性，但这份会被第一次拷贝来的实例属性屏蔽掉
        var sub1 = new Sub(1);
        var sub2 = new Sub(2);
        console.log(sub1.fun === sub2.fun);//true

        // 创建父构造函数
        function Person(name,age){
            this.name = name;
            this.age = age;
            this.showName = function(){
                console.log(this.name);
            }
        }
        // 设置父构造函数的原型对象
        Person.prototype.showAge = function(){
            console.log(this.age);
        }
        // 创建子构造函数
        function Student(name){
            Person.call(this,name);
        }
        // 设置继承
        Student.prototype = Person.prototype;
        Student.prototype.constructor = Student;

        /*
          2.核心：
            把 实例函数放在原型对象上，以实现函数的复用。同时还要保留借用构造函数方式的优点，通过Super.call(this)；继承父类的基本属性和引用属性并且能够保留传参的优点，通过Sun.prototype = new Super();继承父类函数，以实现函数复用 
          优缺点： 
            优点： 
            1.不存在引用属性共享的问题 
            2.可传递参数 
            3.函数可复用 
            缺点： 
            1.子类原型上有一份多余的父类实例属性，因为父类构造函数被调用了两次，生成了两份，而子类实例上的那一份屏蔽了子类原型上的（在代码的注释部分给予解释），内存浪费
            
        */




    </script>
</body>
</html>