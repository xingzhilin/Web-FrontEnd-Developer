# TCP/IP 网络的五层模型
    TCP/IP五层协议和OSI的七层协议对应关系如下

    应用层、表示层、会话层                    应用层

    传输层                                 传输层

    网络层                                 网络层

    数据链路层                              数据链路层

    物理层                                 物理层



## 计算机网络五层协议

## 1.应用层
    任务 ：为操作系统或网络应用程序提供访问网络服务的接口 ，通过应用进程间的交互完成特定网络应用。应用层定义的是应用进程间通信和交互的规则

    常用协议：HTTP、SMTP、FTP、ping、telnet、DNS、DHCP等
    HTTP协议（超文本传输协议）
    主要特点：

    支持客户/服务器模式
    简单快速：客户向服务器请求服务时，只需传送请求方法和路径；请求方法常用GET、HEAD、POST等，每种方法规定了客户与服务器联系的不同类型；HTTP协议简单，服务器程序规模小，通信速度较快
    灵活：HTTP允许传输任意类型的数据对象；正在传输的数据类型由Content-Type加以标记
    无连接：无连接是指每次连接只处理一个请求；服务器处理完客户请求，并收到客户应答后，即断开连接，节省传输时间
    无状态：无状态是指协议对于事务处理没有记忆能力；应答较快，但传输数据量较大
    HTTP URL:定位网络资源

    http://host[:port][abs_path]

        HTTP请求

            三部分组成：请求行、消息报头、请求正文
            格式：Method Request-URI HTTP-Version CRLF
            Method:请求方法，GET、POST等
            Request-URI:请求的HTTP协议版本
            CRLF:回车换行
        HTTP响应

            由三部分组成：状态行、消息报头、响应正文
            状态行格式：HTTP-Version Status-Code Reason-Phrase CRLF
            HTTP-Version:服务器HTTP协议版本
            Status-Code:服务器返回的响应状态码
            HTTP状态码

        由三位数字组成，首数字定义响应类别
            1xx:指示信息，表示请求已接收，继续处理；
            2xx:成功
            3xx:重定向，要完成请求必须进行更进一步的操作；
            4xx:客户端错误，请求有语法错误或请求无法实现
            5xx:服务器端错误：服务器未能实现合法的请求
        常见状态代码

            200：OK,请求成功；
            400：Bad Request,请求有语法错误，不能被服务器所理解；
            401：Unauthorized,请求未经授权；
            403：Forbidden,服务器收到请求，但是拒绝提供服务；
            404：Not Found,请求资源不存在；
            500：Internet Server Error,服务器发生不可预期的错误；
            503：Server Unavailable,服务器不能处理客户请求

    > Respons Header

        Access-Control-Allow-Credentials: true
        Access-Control-Allow-Headers: Origin, X-Requested-With, Content-Type, Accept, token
        Access-Control-Allow-Methods: POST, GET, PATCH, DELETE, PUT, OPTIONS
        Access-Control-Allow-Origin: http://127.0.0.1:33089
        Access-Control-Max-Age: 3600
        Connection: keep-alive
        Content-Type: application/json;charset=UTF-8
        Date: Wed, 21 Aug 2019 02:55:05 GMT
        Server: nginx
        Set-Cookie: JSESSIONID=9A10DB32DEED77B758729971201B29D4; Path=/; HttpOnly
        Transfer-Encoding: chunked
        X-Application-Context: app-gateway:dev:8100

    > Request Header
        Accept: */*
        Accept-Encoding: gzip, deflate, br
        Accept-Language: zh-CN,zh;q=0.9
        Cache-Control: no-cache
        Connection: keep-alive
        Content-Length: 14
        content-type: application/x-www-form-urlencoded
        Host: devminiapi.yangguangzhenxuan.com
        Origin: http://127.0.0.1:33089
        Pragma: no-cache
        Referer: https://servicewechat.com/wx44ba65bfa756ecc3/devtools/page-frame.html
        sec-ch-ua: nwjs 74
        Sec-Fetch-Dest: empty
        Sec-Fetch-Mode: cors
        Sec-Fetch-Site: cross-site
        Sec-Fetch-User: ?F
        token: acb8182a64af425c8ff3d6fd77700bd3
        User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1 wechatdevtools/1.02.1907160 MicroMessenger/7.0.4 Language/zh_CN webview/



## 2.运输层
    任务：负责向两个主机中进程之间的通信提供通用数据服务（为两台主机的应用程序提供端到端通信）

    主要使用以下两种协议：
        传输控制协议TCP ：提供面向连接的 、可靠的、基于流的数据传输服务，数据传输的单位是报文段。使用超时重发、数据确认等方式确保数据被正确发送至目的地
        用户数据报协议UDP：提供无连接的、不可靠的、基于数据报的数据传输服务；数据传输的单位是用户数据报

## 3.网络层
    任务: 负责对数据包进行路由选择和存储转发

    负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段和用户数据报封装成分组（IP数据报）或包进行传送。

    IP协议:逐跳发送模式；根据数据包的目的地IP地址决定数据如何发送；如果数据包不能直接发送至目的地，IP协议负责寻找一个合适的下一跳路由器，并将数据包交付给该路由器转发

    ICMP协议：因特网控制报文协议，用于检测网络连接

## 4.数据链路层
    任务： 负责分配MAC地址

    两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻的链路上传送帧（frame)。每一帧包括数据和必要的控制信息。

    网卡接口的网络驱动程序，处理数据在物理媒介上的传输；不同的物理网络具有电气特性，网络驱动程序隐藏实现细节，为上层协议提供一致接口

    常用协议：地址解析协议（ARP）和反地址解析协议（RARP）,实现IP地址与机器物理地址（MAC地址）之间的转换

## 5.物理层
    物理层所传数据单位是比特（bit)。物理层要考虑用多大的电压代表1 或 0 ，以及接受方如何识别发送方所发送的比特。

## 6.各层对应的工作设备
    物理层：中继器、集线器
    数据链路层：网桥或交换机
    网络层中继系统：路由器
    网络层以上的中继系统：网关

***----------------------------------------------------------------------------------------------------------------***

## 应用层

    HTTP,HTTPS协议,其中HTTP没有对数据进行加密操作,但是HTTPS对数据进行了加密操作 
    其中HTTP端口号一般是80/8080等等,HTTPS端口号是443,SSH端口号一般是22,ftp是21 
    HTTP协议报头:

    首行:请求方法,url,协议版本
    请求报头:
        HOST:主机
        Connection:长连接还是短连接
        Content-Length:标示body的长度
        Accept-Encoding:客户告诉服务器编码类型和语言类型
        Cookie:在客户端保存少量信息,实现会话的功能
        空行
        body

#传输层:
    UDP协议:
    UDP报头格式

    16位源端口号                  16位目的端口号
    16位UDP长度                   16位UDP检验和(保证基本的数据正确性数据可以丢失,但不能把错的                       数据传给应用层)
    数据

    UDP的特点: 
    无连接:知道对方的的IP和端口号就直接进行发送数据,不管对方有没有连接 
    面向数据报:不管应用层给自己交付的报文长度是多少都不会进行组装和拆分,假如发送方一次发送了100个字节,那么接收方也必须对接受的数据一次性接受100字节 
    不可靠传输:UDP没有实现确认机制和重传机制,因此如果数据发生丢失则不会告诉给上层的应用层 
    UDP的缓冲区 
    UDP是调用sendto将数据直接交给内核,内核将数据交给网络层协议进行后续传输动作,UDP有接受缓冲区,当数据在接收方的缓冲区已经满的时候,此时如果再给对方进行数据发送,数据就会丢失 
    UDP是基于全双工的,通信双方既可以读,也可以写 
    UDP传输数据 
    UDP在传输数据的时候最大长度是16位,也就是在传输的过程中最大长度就是64K,如果传输裹过程中数据大于64K,此时就需要应用层将数据进行分包,在到达对方的时候进行解包

    TCP协议
    HTTP协议报头:

        16位源端口号                              16位目的端口号
        32位序列号
        32位确认序列号
        4位首部长度      保留6位        标识位     16位窗口大小
        16位检验和                                16位紧急指针
        选项
        数据

    其中16位的源端口号表示的是来自上层协议中的那个进程,目的端口号表示要交给接受端那个进程.32位序列号和确认序列号保证数据的请求和应答的正确性.同时也可以保证数据的按需到达,由于序列号和序列号也保证了数据的重传机制,也不用再担心丢包问题

    TCP建立连接和释放连接
    连接的建立: 
    客户端向服务器端发送一个SYN请求报文,此时客户端进入SYN_SEND状态,服务器接收到这个数据之后给客户端发送一个ACK确认应答报文,表示自己也已经收到客户端的SYN报文,同时也会发送一个SYN请求报文,同时服务器进入SYN_RECV状态,此时当客户端接收到这个报文之后给服务器端发送一个ACK,此时客户端进入ESTABLISHED,服务器接收到这个报文之后也会进入ESTABLISHED状态 
    为什么要进行三次握手,为什么要等待2*MSL 
    假如只有两次握手,服务器放给客户端的确认信号丢失,此时客户端会认为服务器端没有接受到自己的报文,于是不停给服务器发送无效的报文,势必造成服务器的负担 
    在进行四次握手的时候,当客户端给服务器发送的最后一个报文ACK丢失,此时服务器端没有接受到客户机的ACK,此时他会给服务器发送一个FIN,服务器接收到这个FIN后对客户端进行确认应答,发送一个ACK,此时两次下来刚好就是2*MSL

    TCP保证可靠性的传输手段
    确认应答
    客户端每次给服务器发送SYN,服务器给客户端发送的ACK,同时将自己的应答信号也会带着给发送过去,从而保证了客户端请求,服务器端应答机制,而TCP报头中刚好有序号和确认序号,从而保证了可靠性传输

    超时重传
    当主机A给主机B发送一个数据的时候,此时由于网络的原因造成主机B发送给主机B的确认应答报文丢失,主机B会受到大量的重复的报文,此时主机A会等待特定时间,最后直到最大时间内还没有受到主机B发送给自己的确认应答的时候,此时就会认为对方已经断开连接,于是主机A会强制关闭连接

    流量控制
    在TCP报头中包括了一个窗口大小的字段用来表示自己可以接收的最大报文数量.当主机A向主机B发送一个报文的时候,每次都会看一下主机B的接受窗口,主机B接收到主机A发送给自己的数据之后,此时会将自己的接受窗口写入到TCP报头中窗口字段中,A接受到主机B发送给自己的报文之后,首先先看一下对方窗口大小,如果这个窗口大小比较小了,此时主机A会加快自己发送速度,如果发现接受方的接受窗口比较小的时候,此时就会减慢自己的发送速度,当发现对方的接受窗口为0的时候,此时就会停止自己发送报文.当过一段时间的时候,此时发送方A会给接收方B发送探测数据,以便知道对方的接受窗口的大小

    拥塞控制
    网卡罗上连接了许多的数据,如果一开始的时候各个主机直接给网络发送很多的数据,此时势必会造成网络拥塞.TCP规定了一个拥塞窗口,表示当前网络能够接受的做大数据,每次发送方在发送的时候都会将对方的窗口大小和拥塞窗口进行比较,将较小的数据作为自己的发送窗口. 
    同时在发送的时候规定拥塞窗口大小为1,每接收到一个应答便将拥塞窗口加1,当拥塞窗口的大小大于一个阀值的时候,此时将变为线性增长,同时每次超时重传的时候阀值会降为原来的一半.同时将硬塞窗口变为1

    TCP保证性能传输
    滑动窗口
    滑动窗口左边表示的是已经确认过的,滑动窗口内表示的是已经发出去,但是没有进行确认的,滑动窗口右边的表示的是未发送的数据

    延迟应答
    接受方接受到数据后先不对发送方进行确认,经过一段时间后才对对方发送的数据进行一起确认.

    捎带应答
    每次接收方在对对方的发送数据进行确认的时候,此时也将自己需要发送给接受方的数据也全部发送给接收方

    TCP和UDP的区别
    TCP是面向字节流的,一次读取多少由系统去界定 
    UDP是面向数据报的,发送和接受的时候必须按一定的大小进行发送和接受,不能对数据进行封装以及拆分 
    TCP是保证可靠性的,它为了实现可靠性采用了超时重传,确认应答,流浪控制,拥塞控制等手段,同时为了实现性能可靠性,TCP采用了滑动窗口,捎带应答,延迟应答等等机制 
    UDP没有实现可靠性,它在发送的过程中如果数据发生了丢失,此时就需要上层去确认重传机制 
    TCP主要使用与一些可靠传输场景,比如文件传输等等,但是它实现复杂,传输速度较为慢,UDP主要适用于对速度要求较高的场景,比如视频的传输等等

## 网络层
    为什么要有网络? 
    之所以要有网络层,是因为数据在发送方传输层的时候只有自己的源端口和目标端口,但是不知道对方的IP以及数据应该如何到达对方的目的端口都是不知道的,有了网络层,此时加上路由器就会将数据从远端通过路由转发算法对其进行转发,一直到达对方所在的局域网 
    数据从上层的传输层传下来的时候,此时山层协议有很多,为了区分数据来自上层的哪个协议此时就在IP层的报头中添加了一个8位协议,表示自己接受的数据来自上层协议的那个协议,同时在IP层也有对应的IPV4和IPV6,为了区别两者,也就增加了一个4位版本,同时由于数据进行了封装,那么如和区别自己是正文还是报头信息,此时就需要将自己的数据进行区分,于是便有了首部长度这个字段(4位),同时也有一个8位服务类型,同时16位的总长度表示数据段加上首部整体的长度,由于数据来自上层,有可能数据太大了,于是就需要将数据进行分片,来自上层的同一个数据在经过分片后它的标识是一样的,但是为了防止在IP层对数据进行胡乱的分片,此时就有了3位的表示字段表示是否允许分片.同时既然进行了分片,此时接受方接受到数据后就要进行组装,在进行组装的时候肯定要知道那个数据在前,那个数据在后,于是就需要一个片偏移表示数据的位置,同时在IP层数据要进行路由转发,于是每一个数据都得有自己的一个生存时间,同时也得对首部信息进行校验.既然进行路由转发,此时就需要知道源IP,目的IP,同时也有选项字段(最多40)字节

    4位版本            4位首部长度      8位服务类型          16位总长度
    16位标识符                  3位标识             13位的片偏移
    8位生存时间                  8位协议            16位首部校验和
                                    32位源IP地址
                                32位的目的IP地址
                                        选项
                                        数据
    网段划分
    为什么要有网段划分: 
    之所以要有网段划分是因为网络中有很多的主机,而在这么多的主机中要去找一个主机,那可能会耗费大量的人力物力,所以为了方便找到网络中的每一个主机 
    IP包括网络号和主机号,其中网络号是为了保证两个网段具有不同的标识,端口号是为了保证在同一个网络之间的主机有不同的标识 
    其中同一个子网中的主机之间网络号相同,主机号不同

    ICMP
    和IP相同的是ICMP也是工作在网络层的,但是ICMP不能保证数据是否成功到达对方,而ICMP可以确认数据是否成功到达对方,同时在进行返回的时候会通知IP报被对其的原因,虽然ICMP只能针对IPV4进行使用