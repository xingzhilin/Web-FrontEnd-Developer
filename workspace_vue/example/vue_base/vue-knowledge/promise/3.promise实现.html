
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0,viewport-fit=cover">
    <meta content="yes" name="apple-mobile-web-app-capable"/>
    <meta content="yes" name="apple-touch-fullscreen"/>
    <meta content="telephone=yes,email=no" name="format-detection"/>
    <title></title>
    <!-- <link rel="stylesheet" href="../../../../assets/css/base_reset.css">
    <script type="text/javascript" src="../../../../assets/js/rem.js"></script>
    <script type="text/javascript" src="https://res.wx.qq.com/open/js/jweixin-1.3.2.js"></script> -->
  </head>
  <body>
      <div class="zl-main-wrap" id="app">
        {{initCouponListData}}
      </div>
    <!-- <script type="text/javascript" src="../../../../assets/js/vue.min.js"></script> -->
    <script>
        // Promise构造函数接收一个executor函数，executor函数执行完同步或异步操作后，调用它的两个参数resolve和reject
        var promise = new Promise(function(resolve, reject) {
            /*
                如果操作成功，调用resolve并传入value
                如果操作失败，调用reject并传入reason
            */
        });
        function Promise(executor) {
            var self = this
            self.status = 'pending' // Promise当前的状态
            self.data = undefined  // Promise的值
            self.onResolvedCallback = [] // Promise resolve时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面
            self.onRejectedCallback = [] // Promise reject时的回调函数集，因为在Promise结束之前有可能有多个回调添加到它上面

            executor(resolve, reject) // 执行executor并传入相应的参数
        }




    </script>
  </body>
</html>



<!--
    实现Promise
    Promise标准仅描述了then方法的行为，未对catch、all、race方法进行描述，也未规范如何创建一个Promise对象。ES6中Promise提供了以下API。
    (1) 构造函数
    function Promise(resolver) {}

    (2) 原型方法
    Promise.prototype.then = function() {}
    Promise.prototype.catch = function() {}

    (3) 静态方法
    Promise.resolve = function() {}
    Promise.reject = function() {}
    Promise.all = function() {}
    Promise.race = function() {}

    构造函数


    Promise/A+标准并没有指定如何构造一个Promise对象，我们以ES6原生Promise模块里通过构造函数创建Promise对象的方式实现Promise构造函数。ES6中通过构造函数创建Promise对象的简单用法如下：

    const promise = new Promise((resolve) => {
        setTimeout(()=> {
            resolve(1);
        }, 2000);
    });
    promise.then(a=> alert(a));
    promise.then(a => alert(a+1));

    构造函数用法总结：
    (1) 构造函数接收一个executor立即执行函数
    (2) executor立即执行函数接收一个resolve函数
    (3) promise对象的then方法绑定状态变为fulfilled时的回调
    (4) resolve函数被调用时会触发then方法中的回调

    构造函数的简单实现

    function Promise(executor) {
        var self = this;
        self.status = 'pending'; //promise当前的状态
        self.data = undefined; //promise的值
        self.onResolvedCallback = [];
        //promise状态变为resolve时的回调函数集，可能有多个
    function resolve(value) {
        if(self.status === 'pending') {
            self.status = 'resolved';
            self.data = value;
            for(var i = 0; i < self.onResolvedCallback.length; i++) {
                self.onResolvedCallback[i](value);
            }
        }
    }
    executor(resolve);
    };
    Promise.prototype.then = function (resolve) {
        this.onResolvedCallback.push(resolve);
    };



    executor自执行函数接收的第二个参数为reject函数且reject函数在promise对象状态变为rejected时或executor抛出异常时触发。

    function Promise(executor) {
        var self = this;
        self.status = 'pending'; //promise当前的状态
        self.data = undefined; //promise的值
        self.onResolvedCallback = [];
        //promise状态变为resolve时的回调函数集，可能有多个
        self.onRejectedCallback = [];
        //promise状态变为reject时的回调函数集，可能有多个
    function resolve(value) {
        if(self.status === 'pending') {
            self.status = 'resolved';
            self.data = value;
            for(var i = 0; i < self.onResolvedCallback.length; i++) {
                self.onResolvedCallback[i](value);
            }
        }
    }

    function reject(reason) {
            if(self.status === 'pending') {
                self.status = 'rejected';
                self.data = reason;
                for(var i = 0; i < self.onRejectedCallback.length; i++) {
                    self.onRejectedCallback[i](reason);
                }
            }
    }

    try {
        executor(resolve, reject);
    } catch (e){
        reject(e);
    }
    };
    Promise.prototype.then = function (onResolve, onReject) {
        this.onResolvedCallback.push(onResolve);
        this.onRejectedCallback.push(onReject);
    };

    总结：①executor函数作为实参在创建Promise对象时传入Promise构造函数。②resolve和reject函数作为实参传入executor函数。③value作为实参传入resolve和reject函数。

    如果executor自执行函数中的resolve函数立即触发时，发现Promise失效，例如：

    const promise = new Promise((resolve) => {
        resolve(1);
    });
    promise.then((a) => alert(a));

    解决办法：需要将promise的resolve和reject异步执行。
    function resolve(value) {
        setTimeout(function () {
            if(self.status === 'pending') {
                self.status = 'resolved';
                self.data = value;
                for(var i = 0; i < self.onResolvedCallback.length; i++) {
                    self.onResolvedCallback[i](value);
                }
            }
        })
    }

    function reject(reason) {
        setTimeout(function () {
            if(self.status === 'pending') {
                self.status = 'rejected';
                self.data = reason;
                for(var i = 0; i < self.onRejectedCallback.length; i++) {
                    self.onRejectedCallback[i](reason);
                }
            }
        })
    }

    then方法

    在构造函数中的示例中，then方法并没有返回一个promise对象，而 Promise/A+ 规范中规定then方法用来注册promise对象状态改变时的回调，且返回一个新的promise对象。
    (1) then方法返回一个新的promise对象。
    (2) executor自执行函数中的resolve参数调用时执行then方法的第一个回调函数onResolved。
    (3) executor自执行函数中的reject参数调用时执行then方法的第二个回调函数onRejected。

    Promise.prototype.then = function (onResolved, onRejected) {
        var self = this;
        var promise2;
        onResolved = typeof onResolved === 'function' 
                    ? onResolved 
                    : function (value) {return value};
        onRejected = typeof onRejected === 'function' 
                    ? onRejected 
                    : function (reason) {throw reason};
        //promise对象当前状态为resolved
        if(self.status === 'resolved') {
            return promise2 = new Promise(function (resolve, reject) {
                try {
                    //调用onResolve回调函数
                    var x = onResolved(self.data);
                    //如果onResolve回调函数返回值为一个promise对象
                    if(x instanceof  Promise) {
                        //将它的结果作为promise2的结果
                        x.then(resolve, reject);
                    } else {
                        resolve(x);//执行promise2的onResolve回调
            }        
                } catch (e) {
                    reject(e); //执行promise2的onReject回调
                }
            })
        }
        //promise对象当前状态为rejected
        if(self.status === 'rejected') {
            return promise2 = new Promise(function (resolve, reject) {
                try {
                    var x = onRejected(self.data);
                    if (x instanceof Promise) {
                        x.then(resolve, reject)
                    } else {
                        resolve(x)
                    }
                } catch (e) {
                    reject(e)
                }
            })
        }
        //promise对象当前状态为pending
        //此时并不能确定调用onResolved还是onRejected，需要等当前Promise状态确定。
        //所以需要将callBack放入promise1的回调数组中
        if(self.status === 'pending') {
            return promise2 = new Promise(function (resolve, reject) {
                self.onResolvedCallback.push(function (value) {
                    try {
                        var x = onResolved(self.data);
                        if (x instanceof Promise) {
                            x.then(resolve, reject);
                        } else {
                            resolve(x);
            }
                    } catch (e) {
                        reject(e);
                    }
                })
                self.onRejectedCallback.push(function(reason) {
                    try {
                        var x = onRejected(self.data);
                        if (x instanceof Promise) {
                            x.then(resolve, reject)
                        } else {
                            resolve(x);
                        }
                    } catch (e) {
                        reject(e)
                    }
                })
            })
        }
    };


    参照Promise/A+标准对promise进行改写

    function resolvePromise(promise2, x, resolve, reject) {
        var then
        var thenCalledOrThrow = false

        if (promise2 === x) {
            return reject(new TypeError('Chaining cycle detected for promise!'))
        }
        if (x instanceof Promise) {
            if (x.status === 'pending') { //because x could resolved by a Promise Object
                x.then(function(v) {
                    resolvePromise(promise2, v, resolve, reject)
                }, reject)
            } else { //but if it is resolved, it will never resolved by a Promise Object but a static value;
                x.then(resolve, reject)
            }
            return
        }

        if ((x !== null) && ((typeof x === 'object') || (typeof x === 'function'))) {
            try {
                then = x.then //because x.then could be a getter
                if (typeof then === 'function') {
                    then.call(x, function rs(y) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return resolvePromise(promise2, y, resolve, reject)
                    }, function rj(r) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return reject(r)
                    })
                } else {
                    resolve(x)
                }
            } catch (e) {
                if (thenCalledOrThrow) return
                thenCalledOrThrow = true
                return reject(e)
            }
        } else {
            resolve(x)
        }
    }

    Promise.prototype.then = function(onResolved, onRejected) {
        var self = this
        var promise2
        onResolved = typeof onResolved === 'function' ? onResolved : function(v) {
            return v
        }
        onRejected = typeof onRejected === 'function' ? onRejected : function(r) {
            throw r
        }

        if (self.status === 'resolved') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() { // 异步执行onResolved
                    try {
                        var x = onResolved(self.data)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (reason) {
                        reject(reason)
                    }
                })
            })
        }

        if (self.status === 'rejected') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() { // 异步执行onRejected
                    try {
                        var x = onRejected(self.data)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (reason) {
                        reject(reason)
                    }
                })
            })
        }

        if (self.status === 'pending') {
            // 这里之所以没有异步执行，是因为这些函数必然会被resolve或reject调用，而resolve或reject函数里的内容已是异步执行，构造函数里的定义
            return promise2 = new Promise(function(resolve, reject) {
                self.onResolvedCallback.push(function(value) {
                    try {
                        var x = onResolved(value)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (r) {
                        reject(r)
                    }
                })

                self.onRejectedCallback.push(function(reason) {
                    try {
                        var x = onRejected(reason)
                        resolvePromise(promise2, x, resolve, reject)
                    } catch (r) {
                        reject(r)
                    }
                })
            })
        }
    }

    完整代码
    var Promise = (function() {
        function Promise(resolver) {
            if (typeof resolver !== 'function') { //resolver必须是函数
                throw new TypeError('Promise resolver ' + resolver + ' is not a function')
            }
            if (!(this instanceof Promise)) return new Promise(resolver)

            var self = this //保存this
            self.callbacks = [] //保存onResolve和onReject函数集合
            self.status = 'pending' //当前状态

            function resolve(value) {
                setTimeout(function() { //异步调用
                    if (self.status !== 'pending') {
                        return
                    }
                    self.status = 'resolved' //修改状态
                    self.data = value

                    for (var i = 0; i < self.callbacks.length; i++) {
                        self.callbacks[i].onResolved(value)
                    }
                })
            }

            function reject(reason) {
                setTimeout(function(){ //异步调用
                    if (self.status !== 'pending') {
                        return
                    }
                    self.status = 'rejected' //修改状态
                    self.data = reason

                    for (var i = 0; i < self.callbacks.length; i++) {
                        self.callbacks[i].onRejected(reason)
                    }
                })
            }

            try{
                resolver(resolve, reject) //执行resolver函数
            } catch(e) {
                reject(e)
            }
        }

        function resolvePromise(promise, x, resolve, reject) {
            var then
            var thenCalledOrThrow = false

            if (promise === x) {
                return reject(new TypeError('Chaining cycle detected for promise!'))
            }

            if ((x !== null) && ((typeof x === 'object') || (typeof x === 'function'))) {
                try {
                    then = x.then
                    if (typeof then === 'function') {
                        then.call(x, function rs(y) {
                            if (thenCalledOrThrow) return
                            thenCalledOrThrow = true
                            return resolvePromise(promise, y, resolve, reject)
                        }, function rj(r) {
                            if (thenCalledOrThrow) return
                            thenCalledOrThrow = true
                            return reject(r)
                        })
                    } else {
                        return resolve(x)
                    }
                } catch(e) {
                    if (thenCalledOrThrow) return
                    thenCalledOrThrow = true
                    return reject(e)
                }
            } else {
                return resolve(x)
            }
        }

        Promise.prototype.then = function(onResolved, onRejected) {
            //健壮性处理，处理点击穿透
            onResolved = typeof onResolved === 'function' ? onResolved : function(v){return v}
            onRejected = typeof onRejected === 'function' ? onRejected : function(r){throw r}
            var self = this
            var promise2

            //promise状态为resolved
            if (self.status === 'resolved') {
                return promise2 = new Promise(function(resolve, reject) {
                    setTimeout(function() {
                        try {
                            //调用then方法的onResolved回调
                            var x = onResolved(self.data)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    })
                })
            }

            //promise状态为rejected
            if (self.status === 'rejected') {
                return promise2 = new Promise(function(resolve, reject) {
                    setTimeout(function() {
                        try {
                            //调用then方法的onReject回调
                            var x = onRejected(self.data)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    })
                })
            }

            //promise状态为pending
            //需要等待promise的状态改变
            if (self.status === 'pending') {
                return promise2 = new Promise(function(resolve, reject) {
                    self.callbacks.push({
                        onResolved: function(value) {
                            try {
                                //调用then方法的onResolved回调
                                var x = onResolved(value)
                                //根据x的值修改promise2的状态
                                resolvePromise(promise2, x, resolve, reject)
                            } catch(e) {
                                //promise2状态变为rejected
                                return reject(e)
                            }
                        },
                        onRejected: function(reason) {
                            try {
                                //调用then方法的onResolved回调
                                var x = onRejected(reason)
                                //根据x的值修改promise2的状态
                                resolvePromise(promise2, x, resolve, reject)
                            } catch(e) {
                                //promise2状态变为rejected
                                return reject(e)
                            }
                        }
                    })
                })
            }
        }

        //获取当前Promise传递的值
        Promise.prototype.valueOf = function() {
            return this.data
        }

        //由then方法实现catch方法
        Promise.prototype.catch = function(onRejected) {
            return this.then(null, onRejected)
        }

        //finally方法
        Promise.prototype.finally = function(fn) {
            return this.then(function(v){
                setTimeout(fn)
                return v
            }, function(r){
                setTimeout(fn)
                throw r
            })
        }

        Promise.prototype.spread = function(fn, onRejected) {
            return this.then(function(values) {
                return fn.apply(null, values)
            }, onRejected)
        }

        Promise.prototype.inject = function(fn, onRejected) {
            return this.then(function(v) {
                return fn.apply(null, fn.toString().match(/\((.*?)\)/)[1].split(',').map(function(key){
                    return v[key];
                }))
            }, onRejected)
        }

        Promise.prototype.delay = function(duration) {
            return this.then(function(value) {
                return new Promise(function(resolve, reject) {
                    setTimeout(function() {
                        resolve(value)
                    }, duration)
                })
            }, function(reason) {
                return new Promise(function(resolve, reject) {
                    setTimeout(function() {
                        reject(reason)
                    }, duration)
                })
            })
        }

        Promise.all = function(promises) {
            return new Promise(function(resolve, reject) {
                var resolvedCounter = 0
                var promiseNum = promises.length
                var resolvedValues = new Array(promiseNum)
                for (var i = 0; i < promiseNum; i++) {
                    (function(i) {
                        Promise.resolve(promises[i]).then(function(value) {
                            resolvedCounter++
                            resolvedValues[i] = value
                            if (resolvedCounter == promiseNum) {
                                return resolve(resolvedValues)
                            }
                        }, function(reason) {
                            return reject(reason)
                        })
                    })(i)
                }
            })
        }

        Promise.race = function(promises) {
            return new Promise(function(resolve, reject) {
                for (var i = 0; i < promises.length; i++) {
                    Promise.resolve(promises[i]).then(function(value) {
                        return resolve(value)
                    }, function(reason) {
                        return reject(reason)
                    })
                }
            })
        }

        Promise.resolve = function(value) {
            var promise = new Promise(function(resolve, reject) {
                resolvePromise(promise, value, resolve, reject)
            })
            return promise
        }

        Promise.reject = function(reason) {
            return new Promise(function(resolve, reject) {
                reject(reason)
            })
        }

        Promise.fcall = function(fn){
            // 虽然fn可以接收到上一层then里传来的参数，但是其实是undefined，所以跟没有是一样的，因为resolve没参数啊
            return Promise.resolve().then(fn)
        }

        Promise.done = Promise.stop = function(){
            return new Promise(function(){})
        }

        Promise.deferred = Promise.defer = function() {
            var dfd = {}
            dfd.promise = new Promise(function(resolve, reject) {
                dfd.resolve = resolve
                dfd.reject = reject
            })
            return dfd
        }

        try { // CommonJS compliance
            module.exports = Promise
        } catch(e) {}

        return Promise
    })()

-->